import { DoubleSide, Mesh, MeshLambertMaterial } from 'three';
import { IfcSelection } from './selection';
export class IfcSelector {
    constructor(context, ifc) {
        this.context = context;
        this.ifc = ifc;
        this.userDataField = 'ifcjsFadedModel';
        this.defSelectMat = this.initializeDefMaterial(0xff33ff, 0.3);
        this.defPreselectMat = this.initializeDefMaterial(0xffccff, 0.5);
        this.defHighlightMat = this.initializeDefMaterial(0xeeeeee, 0.05);
        this.preselection = new IfcSelection(context, this.ifc.loader, this.defPreselectMat);
        this.selection = new IfcSelection(context, this.ifc.loader, this.defSelectMat);
        this.highlight = new IfcSelection(context, this.ifc.loader);
    }
    dispose() {
        var _a, _b, _c;
        (_a = this.defPreselectMat) === null || _a === void 0 ? void 0 : _a.dispose();
        this.defHighlightMat = null;
        (_b = this.defSelectMat) === null || _b === void 0 ? void 0 : _b.dispose();
        this.defSelectMat = null;
        (_c = this.defHighlightMat) === null || _c === void 0 ? void 0 : _c.dispose();
        this.defHighlightMat = null;
        this.preselection.dispose();
        this.preselection = null;
        this.selection.dispose();
        this.selection = null;
        this.highlight.dispose();
        this.highlight = null;
    }
    /**
     * Highlights the item pointed by the cursor.
     */
    async prePickIfcItem() {
        const found = this.context.castRayIfc();
        if (!found) {
            this.preselection.hideSelection();
            return;
        }
        await this.preselection.pick(found);
    }
    /**
     * Highlights the item pointed by the cursor and gets is properties.
     * @focusSelection If true, animate the perspectiveCamera to focus the current selection
     */
    async pickIfcItem(focusSelection = false) {
        const found = this.context.castRayIfc();
        if (!found)
            return null;
        const result = await this.selection.pick(found, focusSelection);
        if (result == null || result.modelID == null || result.id == null)
            return null;
        return result;
    }
    /**
     * Highlights the item pointed by the cursor and gets is properties, without applying any material to it.
     * @focusSelection If true, animate the perspectiveCamera to focus the current selection
     */
    async highlightIfcItem(focusSelection = false) {
        const found = this.context.castRayIfc();
        if (!found)
            return null;
        const model = found.object;
        this.fadeAwayModel(model);
        const result = await this.highlight.pick(found, focusSelection);
        if (result == null || result.modelID == null || result.id == null)
            return null;
        return result;
    }
    /**
     * Highlights the item with the given ID with the picking material.
     * @modelID ID of the IFC model.
     * @id Express ID of the item.
     * @focusSelection If true, animate the perspectiveCamera to focus the current selection
     */
    async pickIfcItemsByID(modelID, ids, focusSelection = false) {
        await this.selection.pickByID(modelID, ids, focusSelection);
    }
    /**
     * Highlights the item with the given ID with the prepicking material.
     * @modelID ID of the IFC model.
     * @id Express ID of the item.
     * @focusSelection If true, animate the perspectiveCamera to focus the current selection
     */
    async prepickIfcItemsByID(modelID, ids, focusSelection = false) {
        await this.preselection.pickByID(modelID, ids, focusSelection);
    }
    /**
     * Highlights the item with the given ID and fades away the model.
     * @modelID ID of the IFC model.
     * @id Express ID of the item.
     * @focusSelection If true, animate the perspectiveCamera to focus the current selection
     * @mesh Mesh to fade away. By default it's the IFCModel
     */
    async highlightIfcItemsByID(modelID, ids, focusSelection = false, mesh) {
        const model = mesh || this.context.items.ifcModels[modelID];
        this.fadeAwayModel(model);
        await this.highlight.pickByID(modelID, ids, focusSelection);
    }
    /**
     * Unapplies the picking material.
     */
    unpickIfcItems() {
        this.selection.unpick();
    }
    /**
     * Unapplies the prepicking material.
     */
    unPrepickIfcItems() {
        this.preselection.unpick();
    }
    /**
     * Unapplies the highlight material, removing the fading of the model
     */
    unHighlightIfcItems() {
        this.context.items.ifcModels.forEach((model) => this.unHighlightItem(model));
        this.highlight.unpick();
    }
    unHighlightItem(model) {
        const fadedModel = model.userData[this.userDataField];
        if (fadedModel && fadedModel.parent) {
            fadedModel.parent.add(model);
            fadedModel.removeFromParent();
        }
    }
    fadeAwayModel(model) {
        if (!model.userData[this.userDataField]) {
            model.userData[this.userDataField] = new Mesh(model.geometry, this.defHighlightMat);
        }
        if (model.parent) {
            model.parent.add(model.userData[this.userDataField]);
            model.removeFromParent();
        }
    }
    initializeDefMaterial(color, opacity) {
        const planes = this.context.getClippingPlanes();
        return new MeshLambertMaterial({
            color,
            opacity,
            transparent: true,
            depthTest: false,
            side: DoubleSide,
            clippingPlanes: planes
        });
    }
}
//# sourceMappingURL=selector.js.map